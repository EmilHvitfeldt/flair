#' # Objects defined by decorate_code are created in the current environment for later use.
#'
#' decorate_code('foo <- mean(1:10)')
#'
#' foo + 5
#'
#' @importFrom stringr str_trim str_detect str_replace_all
#' @importFrom purrr map map_lgl quietly
#'
#' @export
decorate_code <- function(text, ...) {
# remove trailing whitespace
text <- str_trim(text)
# get options
my_opts <- knitr::opts_chunk$merge(list(...))
# evaluate code
if (my_opts$eval) {
if (isTRUE(getOption('knitr.in.progress'))) {
scope_and_run(text)
} else {
eval(parse(text = text))
}
}
# Check for flair = FALSE option
if (!is.null(my_opts$flair) && !my_opts$flair) {
placeholder <- list(NULL)
attr(placeholder, "class") = "with_flair"
return(placeholder)
} else {
my_code <- paste0("```{r}\n", text, "\n```")
knitted <- knitr::knit_child(text = text,
options = my_opts,
quiet = TRUE)
}
# convert knitted string to a list with sources separate from output
knitted <- knitted %>% src_to_list()
attr(knitted, "class") <- "with_flair"
return(knitted)
}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(flair)
library(knitr)
library(evaluate)
decorate_code('
mean(1:10)
') %>%
flair_funs()
knit_child
#' Creates an object of the class \code{with_flair}
#'
#' @param text A string, presumably representing R code.
#' @param ...  Any number of default chunk options to override.
#'
#'
#' @return A \code{with_flair} object.
#'
#' @seealso \code{\link{flair}}
#'
#' @examples
#'
#' # When run in console, this will print the results of mean(1:10)
#' my_code <- decorate_code(text = 'mean(1:10)') %>% flair_funs()
#'
#' # The object itself, when printed, previews your code with flair
#'
#' my_code
#'
#'
#' # Objects defined by decorate_code are created in the current environment for later use.
#'
#' decorate_code('foo <- mean(1:10)')
#'
#' foo + 5
#'
#' @importFrom stringr str_trim str_detect str_replace_all
#' @importFrom purrr map map_lgl quietly
#'
#' @export
decorate_code <- function(text, ...) {
# remove trailing whitespace
text <- str_trim(text)
# get options
my_opts <- knitr::opts_chunk$merge(list(...))
# evaluate code
if (my_opts$eval) {
if (isTRUE(getOption('knitr.in.progress'))) {
scope_and_run(text)
} else {
eval(parse(text = text))
}
}
# Check for flair = FALSE option
if (!is.null(my_opts$flair) && !my_opts$flair) {
placeholder <- list(NULL)
attr(placeholder, "class") = "with_flair"
return(placeholder)
} else {
my_code <- paste0("```{r}\n", text, "\n```")
knitted <- knitr::knit_child(text = text,
options = my_opts,
quiet = TRUE)
}
# convert knitted string to a list with sources separate from output
knitted <- knitted %>% src_to_list()
attr(knitted, "class") <- "with_flair"
return(knitted)
}
decorate_code('
mean(1:10)
') %>%
flair_funs()
#' Creates an object of the class \code{with_flair}
#'
#' @param text A string, presumably representing R code.
#' @param ...  Any number of default chunk options to override.
#'
#'
#' @return A \code{with_flair} object.
#'
#' @seealso \code{\link{flair}}
#'
#' @examples
#'
#' # When run in console, this will print the results of mean(1:10)
#' my_code <- decorate_code(text = 'mean(1:10)') %>% flair_funs()
#'
#' # The object itself, when printed, previews your code with flair
#'
#' my_code
#'
#'
#' # Objects defined by decorate_code are created in the current environment for later use.
#'
#' decorate_code('foo <- mean(1:10)')
#'
#' foo + 5
#'
#' @importFrom stringr str_trim str_detect str_replace_all
#' @importFrom purrr map map_lgl quietly
#'
#' @export
decorate_code <- function(text, ...) {
# remove trailing whitespace
text <- str_trim(text)
# get options
my_opts <- knitr::opts_chunk$merge(list(...))
# check context
is_live <- !isTRUE(getOption('knitr.in.progress'))
# evaluate code
if (my_opts$eval) {
if (!is_live) {
scope_and_run(text)
} else {
print(eval(parse(text = text)))
}
}
# Check for flair = FALSE option
if (!is.null(my_opts$flair) && !my_opts$flair) {
placeholder <- list(NULL)
attr(placeholder, "class") = "with_flair"
return(placeholder)
} else {
my_code <- paste0("```{r}\n", text, "\n```")
knitted <- knitr::knit_child(text = my_code,
options = my_opts,
quiet = TRUE)
}
# convert knitted string to a list with sources separate from output
knitted <- knitted %>% src_to_list()
attr(knitted, "class") <- "with_flair"
return(knitted)
}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(flair)
library(knitr)
library(evaluate)
decorate_code('
mean(1:10)
') %>%
flair_funs()
?knit
#' Creates an object of the class \code{with_flair}
#'
#' @param text A string, presumably representing R code.
#' @param ...  Any number of default chunk options to override.
#'
#'
#' @return A \code{with_flair} object.
#'
#' @seealso \code{\link{flair}}
#'
#' @examples
#'
#' # When run in console, this will print the results of mean(1:10)
#' my_code <- decorate_code(text = 'mean(1:10)') %>% flair_funs()
#'
#' # The object itself, when printed, previews your code with flair
#'
#' my_code
#'
#'
#' # Objects defined by decorate_code are created in the current environment for later use.
#'
#' decorate_code('foo <- mean(1:10)')
#'
#' foo + 5
#'
#' @importFrom stringr str_trim str_detect str_replace_all
#' @importFrom purrr map map_lgl quietly
#'
#' @export
decorate_code <- function(text, ...) {
# remove trailing whitespace
text <- str_trim(text)
# get options
my_opts <- knitr::opts_chunk$merge(list(...))
# check context
is_live <- !isTRUE(getOption('knitr.in.progress'))
# evaluate code
if (my_opts$eval) {
if (!is_live) {
scope_and_run(text)
} else {
print(eval(parse(text = text)))
}
}
# Check for flair = FALSE option
if (!is.null(my_opts$flair) && !my_opts$flair) {
placeholder <- list(NULL)
attr(placeholder, "class") = "with_flair"
return(placeholder)
} else {
my_code <- paste0("```{r}\n", text, "\n```")
if (is_live) {
knitted <- knitr::knit(text = my_code,
quiet = TRUE)
} else {
knitted <- knitr::knit_child(text = my_code,
options = my_opts,
quiet = TRUE)
}
# convert knitted string to a list with sources separate from output
knitted <- knitted %>% src_to_list()
attr(knitted, "class") <- "with_flair"
return(knitted)
}
)
#' Creates an object of the class \code{with_flair}
#'
#' @param text A string, presumably representing R code.
#' @param ...  Any number of default chunk options to override.
#'
#'
#' @return A \code{with_flair} object.
#'
#' @seealso \code{\link{flair}}
#'
#' @examples
#'
#' # When run in console, this will print the results of mean(1:10)
#' my_code <- decorate_code(text = 'mean(1:10)') %>% flair_funs()
#'
#' # The object itself, when printed, previews your code with flair
#'
#' my_code
#'
#'
#' # Objects defined by decorate_code are created in the current environment for later use.
#'
#' decorate_code('foo <- mean(1:10)')
#'
#' foo + 5
#'
#' @importFrom stringr str_trim str_detect str_replace_all
#' @importFrom purrr map map_lgl quietly
#'
#' @export
decorate_code <- function(text, ...) {
# remove trailing whitespace
text <- str_trim(text)
# get options
my_opts <- knitr::opts_chunk$merge(list(...))
# check context
is_live <- !isTRUE(getOption('knitr.in.progress'))
# evaluate code
if (my_opts$eval) {
if (!is_live) {
scope_and_run(text)
} else {
print(eval(parse(text = text)))
}
}
# Check for flair = FALSE option
if (!is.null(my_opts$flair) && !my_opts$flair) {
placeholder <- list(NULL)
attr(placeholder, "class") = "with_flair"
return(placeholder)
} else {
my_code <- paste0("```{r}\n", text, "\n```")
if (is_live) {
knitted <- knitr::knit(text = my_code,
quiet = TRUE)
} else {
knitted <- knitr::knit_child(text = my_code,
options = my_opts,
quiet = TRUE)
}
# convert knitted string to a list with sources separate from output
knitted <- knitted %>% src_to_list()
attr(knitted, "class") <- "with_flair"
return(knitted)
}
}
decorate_code('
mean(1:10)
') %>%
flair_funs()
decorate_code('
mean(1:10)
') %>%
flair_funs()
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(flair)
library(knitr)
library(evaluate)
decorate_code('
mean(1:10)
') %>%
flair_funs()
decorate_code('
mean(1:10)
') %>%
flair_funs()
decorate_code('
mean(1:10
', eval = FALSE) %>%
flair_funs()
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(flair)
library(knitr)
library(evaluate)
decorate_code('
mean(1:10)
') %>%
flair_funs()
decorate_code('
mean(1:10
', eval = FALSE) %>%
flair_funs()
decorate_code('
mean(1:10)
') %>%
flair_funs()
decorate_code('
mean(1:10
', eval = FALSE) %>%
flair_funs()
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(flair)
library(knitr)
library(evaluate)
decorate_code('
a <- mean(1:10)
') %>%
flair_funs()
a
decorate_code('
a <- mean(1:10)
') %>%
flair_funs()
a
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(flair)
library(knitr)
library(evaluate)
decorate_code('
a <- mean(1:10)
') %>%
flair_funs()
decorate_code('
mean(1:10
', error = TRUE) %>%
flair_funs()
a
scope_and_run
flair:::scope_and_run
.code_string = "a <- mean(1:10)"
if (stringr::str_detect(.code_string, "^[^\\s]+\\s*\\<\\-")) {
.code_string %>%
str_replace("(?!=\\<)\\<\\-", "<<-") %>%
parse(text = .) %>%
eval()
}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(flair)
library(knitr)
library(evaluate)
decorate_code('
a <- mean(1:10)
')
decorate_code('
a <- mean(1:10)
')
decorate_code('
a <- mean(1:10)
') %>%
flair_funs()
decorate_code('
mean(1:10
', error = TRUE) %>%
flair_funs()
library(tidyverse)
library(quantreg)
set.seed(6531)
x <- rnorm(10)
df <- tibble(
x = x,
y = x^2 + 0.5 * rnorm(10)
)
df
ps <- ggplot(df, aes(x, y))+  geom_quantile()
?geom_quantie
?geom_quantilee
?geom_quantile
ggplot(df, aes(x, y))+  geom_quantile()
rq
seq(min(x), max(x), length = 100)
pred.rq <- cbind(seq(min(x), max(x), length = 100), pred.rq)
colnames(pred.rq) <- c("x", paste("Q", q.t * 100, sep = "_"))
q.t <- c(0.25,0.5,0.75)
pred.rq <- cbind(seq(min(x), max(x), length = 100), pred.rq)
colnames(pred.rq) <- c("x", paste("Q", q.t * 100, sep = "_"))
pred_rq <- predict(rq(y ~ x,
tau = q.t,
data = df),
data_frame(
x = seq(min(x), max(x), length = 100)))
pred_rq <- predict(rq(y ~ x,
tau = q.t,
data = df),
tibble(
x = seq(min(x), max(x), length = 100)))
pred_rq <- cbind(seq(min(x), max(x), length = 100), pred_rq)
pred_req
pred_rq
?rq
ggplot.data <- as_tibble(layer_data(ps))
ggplot_data
ps <- ggplot(df, aes(x, y))+  geom_quantile(y ~ x)
?geom_quantile
ps <- ggplot(df, aes(x, y))+  geom_quantile()
ggplot.data <- as_tibble(layer_data(ps))
ggplot.data
expect_equal(ggplot_data[, c("x", "y")],
pred_rq[, c("x", "Q_25")])
library(testthat)
expect_equal(ggplot_data[, c("x", "y")],
pred_rq[, c("x", "Q_25")])
ggplot_data <- as_tibble(layer_data(ps))
expect_equal(ggplot_data[, c("x", "y")],
pred_rq[, c("x", "Q_25")])
head(pred_rq)
ps <- ggplot(df, aes(x, y))+  geom_quantile()
quants <- c(0.25,0.5,0.75)
pred_rq <- predict(rq(y ~ x,
tau = q.t,
data = df),
tibble(
x = seq(min(x), max(x), length = 100)))
pred_rq <- cbind(seq(min(x), max(x), length = 100), pred_rq)
colnames(pred_rq) <- c("x", paste("Q", quants * 100, sep = "_"))
ggplot_data <- as_tibble(layer_data(ps))
pred.rq.test <- pred.rq[, c("x", "Q_25")]
colnames(pred.rq.test) <- c("x","y")
expect_equal(ggplot_data[, c("x", "y")],
pred_rq[, c("x", "Q_25")])
pred_rq_test_25 <- pred_rq[, c("x", "Q_25")]
colnames(pred_rq_test) <- c("x","y")
expect_equal(ggplot_data[, c("x", "y")],
pred_rq_test_25)
pred_rq_test_25 <- pred_rq[, c("x", "Q_25")]
colnames(pred_rq_test_25) <- c("x","y")
expect_equal(ggplot_data[, c("x", "y")],
pred_rq_test_25)
ps <- ggplot(df, aes(x, y))+  geom_quantile()
quants <- c(0.25,0.5,0.75)
pred_rq <- predict(rq(y ~ x,
tau = q.t,
data = df),
tibble(
x = seq(min(x), max(x), length = 100)))
pred_rq <- cbind(seq(min(x), max(x), length = 100), pred_rq)
colnames(pred_rq) <- c("x", paste("Q", quants * 100, sep = "_"))
ggplot_data <- as_tibble(layer_data(ps))
pred_rq_test_25 <- pred_rq[, c("x", "Q_25")]
colnames(pred_rq_test_25) <- c("x","y")
expect_equal(ggplot_data[, c("x", "y")],
pred_rq_test_25)
ggplot_data
"25    0032    Jane S. Doe    999"
bob <- "25    0032    Jane S. Doe    999"
str_split(bob, "\\s+")
str_split(bob, "\\s{2,}")
str_split(bob, "\\s{2,}") %>% unlist()
str_split(bob, "([\\t\\r]+)|(\\s{2,})") %>% unlist()
